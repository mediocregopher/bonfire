# bonfire

A simple service which coordinates UDP connections between peers in a p2p
application.

## Use-case

bonfire allows peers to announce themselves to a p2p network, ensure other peers
in the network can connect to them, and finding other peers to connect with.

The rough protocol for doing so is as follows:

1) `peerA`, a new peer to the p2p network, opens any UDP listen port. `peerA`
may be behind any number of NATs, it does not know yet.

2) `peerA` sends some number of `Hello` messages from that port to the bonfire
server, `serverA`, whose ip/port must be known ahead of time.

3) For each `Hello`, `serverA` sends one `Meet` message, containing the source
address it saw from `peerA`, to peers `peerB,peerC,...peerN`. The peers it sends
the `Meet` messages to are known to be "ready to mingle" (more on that in step
5).

4) Peers `peerB,peerC,...peerN` send some number of `Hello` messages to `peerA`.

5) When `peerA` receives some number of `Hello` messages, it is done connecting
(i.e. it has met and can communicate with other host in the network). If `peerA`
never receives any `Hello` messages from other peers, it may need to perform
gateway port forwarding or some other steps before going back to step 1.

6) `peerA` may then send some number of `ReadyToMingle` messages to `serverA`,
which can then send `Meet` messages to `peerA` as needed (see step 3). A peer
which chooses not to do this is called anti-social.

## Protocol

A bonfire message is encapsulated in a single UDP packet. It is composed of the
following sequential fields. Each field but the last is of a fixed byte size,
with bytes being in big-endian (network) order.

TODO make fingerprint bigger to allow for hmacs

```
[msgVersion:1][fingerprint:64][msgType:1][body...]
```

* `msgVersion` (1 byte): used to possibly enable backwards incompatible-changes
  in the future. The version being discussed is version `0`.

* `fingerprint` (64 bytes): a random set of bytes which is generated by the
  peer. The purpose is to allow the peer to differentiate between incoming
  bonfire packets on its UDP port and incoming application packets. The
  `fingerprint` is large enough to also serve double-duty as an authentication
  mechanism, so a bonfire server may drop packets from unknown hosts. The
  mechanism must be pre-arranged between the peer and server, and is not defined
  in this spec.

    * `fingerprintA` is generated and sent with the first `Hello` message to
      the server (step 2).

    * The server will send `fingerprintA` in its `Meet` messages to the
      ready-to-mingle peers (step 3).

    * The ready-to-mingle peers will then use `fingerprintA` when sending
      `Hello` messages back to the original peer (step 4).

    * A peer may use any fingerprint in `ReadyToMingle` messages (step 6).

* `msgType` (1 byte): An indicator of what type of message is being
  sent/received. The message type affects what further fields are expected in
  the body of the message.

    * `0` -> `Hello` message, no further fields expected.

    * `1` -> `Meet` message, further fields: `[proto:1][...]`. `proto` is an
      indicator of the protocol the peer to be met is listening on, and its
      value affects what further fields are expected. Currently only one
      protocol is supported:

        * `0` -> UDP, further fields: `[port:2][ip:?]`. `port` is the 16-bit
          integer value indicating which UDP port the peer to be met is
          listening on. `ip` is the byte encoded ipv4 or ipv6 address the peer
          to be met can be found at. The size of ip can be used to determine
          which version it is (ipv4: 4 bytes, ipv6: 16 bytes).

    * `2` -> `ReadyToMingle` message, no further fields expected.

The maximum message size possible is 85 bytes (a `Meet` message using ipv6). Any
packet which is larger, or does not conform to expected field values, may be
discarded by any peer or bonfire server.
